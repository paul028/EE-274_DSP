
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>EE 274 Digital Signal Processing 1 Lab Activity 1</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-10-01"><meta name="DC.source" content="EE274_ProgEx01_A.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>EE 274 Digital Signal Processing 1 Lab Activity 1</h1><!--introduction--><p>Name: Paul Vincent S. Nonat</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">A. Signal Generation</a></li><li><a href="#9">B. SIGNAL REPRESENTATION</a></li><li><a href="#14">C. Sampling</a></li><li><a href="#19">D. Aliasing</a></li><li><a href="#24">E. Quantization</a></li></ul></div><h2 id="1">A. Signal Generation</h2><p>In this exercise, you will demonstrate your coding skills in MATLAB by generating the following signals:</p><div><ol><li>[y,n] = impseq(n0,a,b)</li><li>[y,n] = stepseq(n0,a,b)</li><li>[y,n] = sigadd(x1,n1,x2,n2)</li><li>[y,n] = sigmult(x1,n1,x2,n2)</li><li>[y,n] = sigshift(x1,n1,n0)</li><li>[y,n] = sigfold(x1,n1)</li><li>[xe,xo,n] = evenodd(x1,n1)</li></ol></div><div><ul><li>Demo of impseq function <b>[y,n] = impseq(n0,a,b)</b></li></ul></div><pre class="codeinput">[y,n] = impseq(3,0,5)
figure
stem (n,y)
title(<span class="string">'A.1. Unit-Impulse Sequence'</span>)
xlabel(<span class="string">'n'</span>)
ylabel(<span class="string">'x(n)'</span>)
</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_01.png" alt=""> <div><ul><li>Demo of Unit-step sequence function <b>[y,n] = stepseq(n0,a,b)</b></li></ul></div><pre class="codeinput">[y,n]  = stepseq(3,0,5)
figure
stem(n,y)
title(<span class="string">'A.2. Unit-step Sequence'</span>)
xlabel(<span class="string">'n'</span>)
ylabel(<span class="string">'x(n)'</span>)
</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_02.png" alt=""> <div><ul><li>Demo of addition of two sequence  <b>[y,n] = sigadd(x1,n1,x2,n2)</b></li></ul></div><pre class="codeinput">[y1,n1] = impseq(3,0,5) <span class="comment">%generate impulse sequence</span>
[y2,n2]  = stepseq(3,0,5) <span class="comment">%generate unit-step sequence</span>
[y,n] = sigadd(y1,n1,y2,n2) <span class="comment">% add the unit step and unit impulse sequence</span>
figure
stem(n,y)
title(<span class="string">'A.3 Addition of Two Sequence'</span>)
ylabel(<span class="string">'y = x1(n1)+ x2(n2)'</span>)
xlabel(<span class="string">'n'</span>)
</pre><pre class="codeoutput">
y2 =

  1&times;6 logical array

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_03.png" alt=""> <div><ul><li>Demo of multiplication of two sequence <b>[y,n] = sigmult(x1,n1,x2,n2)</b></li></ul></div><pre class="codeinput">[y1,n1] = impseq(3,0,5) <span class="comment">%generate impulse sequence</span>
[y2,n2]  = stepseq(3,0,5) <span class="comment">%generate unit-step sequence</span>
[y,n] = sigmult(y1,n1,y2,n2) <span class="comment">% add the unit step and unit impulse sequence</span>
figure
stem(n,y)
title(<span class="string">'A.4 Multiplication of Two Sequence'</span>)
ylabel(<span class="string">'y = x1(n1)* x2(n2)'</span>)
xlabel(<span class="string">'n'</span>)
</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_04.png" alt=""> <div><ul><li>Demo of signal shifting <b>[y,n] = sigshift(x1,n1,n0)</b></li></ul></div><pre class="codeinput">[y1,n1] = impseq(3,0,5) <span class="comment">% generate impulse sequence</span>
[y,n] = sigshift(y1,n1,1) <span class="comment">% shift impulse sequence by 1</span>
figure
stem(n,y)
title(<span class="string">'A.5 Shifting Operation on a Sequence'</span>)
ylabel(<span class="string">'x[n-n0]'</span>)
xlabel(<span class="string">'n'</span>)
</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_05.png" alt=""> <div><ol><li>Demo of signal folding  <b>[y,n] = sigfold(x1,n1)</b></li></ol></div><pre class="codeinput">[y1,n1]  = stepseq(3,0,5)
[y,n]= sigfold(y1,n1)
figure
stem(n,y)
title(<span class="string">'A.6 Folding operation on a sequence'</span>)
ylabel(<span class="string">'FD[x(n)]'</span>)
xlabel(<span class="string">'n'</span>)
</pre><pre class="codeoutput">
y1 =

  1&times;6 logical array

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_06.png" alt=""> <div><ul><li>Demo of odd even signal decomposition <b>[xe,xo,m] = evenodd(x,n)</b></li></ul></div><pre class="codeinput">[y1,n1] = impseq(3,0,5) <span class="comment">%generate impulse sequence</span>
[y2,n2]  = stepseq(3,0,5) <span class="comment">%generate unit-step sequence</span>
[y,n] = sigmult(y1,n1,y2,n2) <span class="comment">% add the unit step and unit impulse sequence</span>
[xe,xo,m] = evenodd(y,n)
subplot(311)
stem(n,y)
title(<span class="string">'Original'</span>)
subplot(312)
stem(m,xe)
title(<span class="string">'Even Part'</span>)
subplot(313)
stem(m,xo)
title(<span class="string">'Odd Part'</span>)
</pre><pre class="codeoutput">
y2 =

  1&times;6 logical array

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_07.png" alt=""> <h2 id="9">B. SIGNAL REPRESENTATION</h2><p>Generate and Plot the following signals. You may use your functions in Part A.</p><p><img src="EE274_ProgEx01_A_eq16166352655702929496.png" alt="$$x_1(n) = \sum_{m=0}^{10}(m+1)[\delta(n-2m) - \delta(n-2m-1)]$" style="width:306px;height:43px;"></p><pre class="codeinput">y=0
N=25
nn=0:N
<span class="keyword">for</span> n =0:N
<span class="keyword">for</span> m =0:10
    temp=(m+1) .*( impseq(n-2*m,0,N) - impseq(n-(2*m)-1,0,N))
    y=y+temp
<span class="keyword">end</span>
<span class="keyword">end</span>
figure
stem(nn,y)
xlabel(<span class="string">'n'</span>)
title(<span class="string">'$x_1(n) = \sum_{m=0}^{10}(m+1)[\delta(n-2m) - \delta(n-2m-1)]$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
</pre><pre class="codeoutput">
y =

     0

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_08.png" alt=""> <p><img src="EE274_ProgEx01_A_eq14023437236174815467.png" alt="$x_2(n) = n^2[ u(n+5) - u(n-6)] + 10\delta(n) +20(0.5)n[u(n-4)-u(n-10)]$" style="width:473px;height:16px;"></p><pre class="codeinput">y=0
N=25
nn=0:N
<span class="keyword">for</span> n=0:25
temp = n^2 .* (stepseq(n+5,0,N) - stepseq(n-6,0,N)) + (10 .* impseq(n,0,N)) + 20*(0.5)^n .*(stepseq(n-4,0,N) - stepseq(n-1,0,N))
y=y+temp
<span class="keyword">end</span>
figure
stem(nn,y)
xlabel(<span class="string">'n'</span>)
title(<span class="string">'$x_2(n) = n^2[ u(n+5) - u(n-6)] + 10\delta(n) +20(0.5)n[u(n-4)-u(n-10)]$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
</pre><pre class="codeoutput">
y =

     0

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_09.png" alt=""> <p><img src="EE274_ProgEx01_A_eq14664704741630706134.png" alt="$x_3(n)= (0.9)^n cos(0.2\pi n + \frac{\pi}{3})$" style="width:185px;height:17px;"></p><pre class="codeinput">N=20
n = 0:N;
x0 = 0.9;
x = (0.9^L)*cos(0.2*pi*n+(pi/3));
stem(n,x)
xlabel(<span class="string">'n'</span>)
title(<span class="string">' $x_3(n)= (0.9)^n cos(0.2\pi n + \frac{\pi}{3})$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
</pre><pre class="codeoutput">
N =

    20

</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_10.png" alt=""> <p><img src="EE274_ProgEx01_A_eq03848622175253242417.png" alt="$x_4(n) = 10cos(0.0008\pi n^2) + w(n)$" style="width:212px;height:16px;"></p><pre class="codeinput">N=100
n=0:N;
x0=10;
w = -1+2*rand(1,N+1);
x =(x0*cos(0.0008*pi*(n.^2))) + w
stem(n,x)
xlabel(<span class="string">'n'</span>)
title(<span class="string">' $x_4(n) = 10cos(0.0008\pi n^2) + w(n)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
</pre><pre class="codeoutput">
N =

   100

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_11.png" alt=""> <p><img src="EE274_ProgEx01_A_eq02620682651151946409.png" alt="$x_5(n) = {...,1,2,3,2,1,2,3,2,...}$" style="width:194px;height:15px;"></p><pre class="codeinput"><span class="comment">%N=20</span>
<span class="comment">%</span>
<span class="comment">%y,n]  = stepseq(0,0,2)</span>
</pre><h2 id="14">C. Sampling</h2><pre class="codeinput"><span class="comment">%Sampling is done by periodically obtaining samples from a continuous time</span>
<span class="comment">%signal. The period also known as the sampling period is the reciprocal of</span>
<span class="comment">%sampling frequency $F_s$. Using up-sampling and down-sampling, information</span>
<span class="comment">%can be added or removed from a discrete time signal.</span>
<span class="comment">%</span>
<span class="comment">% # Load *signal1.wave* file in your workspace</span>
<span class="comment">% # Using *[y,fs] = audioread()*, import the audio and sampling rate</span>
<span class="comment">% information in your workspace.</span>
<span class="comment">%</span>
[y,fs]=audioread(<span class="string">'signal1.wav'</span>);
info=audioinfo(<span class="string">'signal1.wav'</span>);
t = 0:seconds(1/fs):seconds(info.Duration);
t = t(1:end-1);

plot(t,y)
title(<span class="string">'Original Audio'</span>)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Audio Signal'</span>)
soundsc(y,fs)
</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_12.png" alt=""> <pre class="codeinput"><span class="comment">%y up-sampled by 2</span>
M=2
y1= upsample(y,M)
t1 = 0:seconds(1/(M*fs)):seconds(info.Duration);
t1 = t1(1:end-1);
figure
plot(t1,y1)
title(<span class="string">'y Up-sampled by 2'</span>)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'y1=y(n/2)'</span>)
soundsc(y1,fs)
</pre><pre class="codeoutput">
M =

     2

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_13.png" alt=""> <pre class="codeinput"><span class="comment">%y down-sampled by 2</span>
M=2
y2= downsample(y,M)
t2 = 0:seconds(1/(fs/M)):seconds(info.Duration);
t2 = t2(1:end-1);
figure
plot(t2,y2)
title(<span class="string">'y down-sampled by 2'</span>)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'y2=y(2n)'</span>)
soundsc(y2,fs)
</pre><pre class="codeoutput">
M =

     2

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_14.png" alt=""> <pre class="codeinput"><span class="comment">%y2 up-sampled by 2</span>
M=2
y3 = upsample(y2,M)
t3 = 0:seconds(1/fs):seconds(info.Duration);
t3 = t3(1:end-1);
figure
plot(t3,y3)
title(<span class="string">'y2 up-sampled by 2'</span>)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'y3=y2(n/2)'</span>)
soundsc(y3,fs)
</pre><pre class="codeoutput">
M =

     2

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_15.png" alt=""> <pre class="codeinput"><span class="comment">%y3, up-sampled by 2</span>
M=2
y4 = upsample(y3,M)
t4 = 0:seconds(1/(fs*M)):seconds(info.Duration);
t4 = t4(1:end-1);
figure
plot(t4,y4)
title(<span class="string">'y3 up-sampled by 2'</span>)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'y4=y3(n/2)'</span>)
soundsc(y4,fs)

<span class="comment">%yes however some information will be loss as the upsampler cannot predict</span>
<span class="comment">%the value inbetween the downsampled signales. In effect, there are loss</span>
<span class="comment">%information in the upsampled signals $y_3$ and $y_4$.</span>
</pre><pre class="codeoutput">
M =

     2

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_16.png" alt=""> <h2 id="19">D. Aliasing</h2><p>The following exercise investigates the effect of improper sampling.</p><div><ol><li>Generate two 1 kHz sine signals (2 seconds duration), first signal at 8 kHz sample frequency and second signal at 1.2 kHz sample frequency</li><li>On the same graph, use the plot function to display the two signals versus t in the range <img src="EE274_ProgEx01_A_eq06039907533450692140.png" alt="$0 \leq t \leq 5$" style="width:58px;height:12px;"> msec.</li><li>Listen to the two signals one after another using the function <b>soundsc (x, fs)</b>;</li><li>Compare the two signals. How does the sampling rate affect the digitized sound?</li></ol></div><pre class="codeinput">T = 2; <span class="comment">%parameters</span>
f0 = 1000; <span class="comment">% 1kHz sine signal</span>
fs1 = 8000; <span class="comment">% Sampling frequencies</span>
fs2 = 1200;
[x1, t1] = sin_NU(fs1,f0,T); <span class="comment">% sine signal sampled at fs1</span>
[x2, t2] = sin_NU(fs2,f0,T); <span class="comment">% sine signal sampled at fs2</span>
figure;
plot(t1,x1,t2,x2,<span class="string">'LineWidth'</span>,3.0),
axis([0, 0.005, -1.1, 1.1])
legend(<span class="string">'fs_1=8 kHz'</span>,<span class="string">'fs_2=1.2 kHz'</span>)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Signals'</span>)
title(<span class="string">'Audio aliasing'</span>);
</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_17.png" alt=""> <pre class="codeinput">soundsc(x1,fs1)
</pre><pre class="codeinput">soundsc(x2,fs2)
</pre><p>based from observation, the sine wave sampled at <img src="EE274_ProgEx01_A_eq13925514905457031967.png" alt="$F_s2$" style="width:21px;height:13px;"> does not completely recovered the original sine wave at $f_o =1$kHz as compared to <img src="EE274_ProgEx01_A_eq00250297007660076585.png" alt="$F_s1$" style="width:21px;height:13px;"> with frequency lower than <img src="EE274_ProgEx01_A_eq07426264330839041685.png" alt="$2F_max$" style="width:42px;height:13px;">, which leads to aliasing.</p><h2 id="24">E. Quantization</h2><pre class="codeinput"><span class="comment">%Quantization is done by replacing each value of an analog signal $x(t)$ by</span>
<span class="comment">%the value of the nearest quantization level. To exemplify this oepration,</span>
<span class="comment">%let's simulate a unipolar ADC (Analog to Digital Converter) having the</span>
<span class="comment">%technical specifications: R= 10 Volts (full-scale range) and B = 3(number</span>
<span class="comment">%of bits).</span>
<span class="comment">%</span>
<span class="comment">% # Write a MATLAB function y=adc_uni(x,R,B) where x and y are vectors</span>
<span class="comment">% containing the input signal and the quantized signal, respectively.</span>
<span class="comment">% # Test your function with an input ramp signal ranging from -5 to 15</span>
<span class="comment">% Volts (1 volt per step).</span>
<span class="comment">% # On the same graph, use the plot and stem functions to display the input</span>
<span class="comment">% signal and quantized signal respectively.</span>
</pre><p>adc_uni function test</p><pre class="codeinput">R = 10;
B = 3;
x = -5:15;
y = adc_uni(x,R,B);
t = 0:length(x)-1;
figure(11)
plot(t,x,t,y)
plot(t,x,<span class="string">'g-*'</span>,<span class="string">'LineWidth'</span>,2.2)
hold <span class="string">on</span>
stem(t,y,<span class="string">'filled'</span>,<span class="string">'LineWidth'</span>,2.2)
hold <span class="string">off</span>
title(<span class="string">'Ramp function unipolar quantization'</span>)
xlabel(<span class="string">'Time in sec'</span>)
ylabel(<span class="string">'Signal magnitude in volts'</span>)
axis([-0.1,20.1,-5.1,15.1])
</pre><pre class="codeinput"><span class="keyword">function</span> y = adc_uni(x, R, B)
level = [0:R/(2^B):R-R/(2^B)];
temp = [-Inf,(level(2:end)-R/(2^(B+1))),Inf];
i=1
y=(x &gt;= temp(i)).*(x &lt; temp(i+1)).*level(i)
<span class="keyword">for</span> i = 2:length(level)
    y = y + (x &gt;= temp(i)).*(x &lt; temp(i+1)).*level(i);
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
i =

     1

...</pre><img vspace="5" hspace="5" src="EE274_ProgEx01_A_18.png" alt=""> <pre class="codeinput"><span class="keyword">function</span> [x, t] = sin_NU(fs, f0, T) <span class="comment">%function to generate sine signal</span>
t = 0:1/fs:T; <span class="comment">%the signal vector output</span>
x = sin(2*pi*f0*t); <span class="comment">%the time vector output</span>
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">function</span> [x,n]=impseq(n0,a,b)
<span class="comment">% Generates x(n)= delta(n-n0); a&lt;=n&lt;=b</span>
n=[a:b]; x=[(n-n0)==0];
<span class="keyword">end</span>
</pre><pre class="codeoutput">
y =

  1&times;6 logical array

...</pre><pre class="codeoutput">
y1 =

  1&times;6 logical array

...</pre><pre class="codeoutput">
y1 =

  1&times;6 logical array

...</pre><pre class="codeoutput">
y1 =

  1&times;6 logical array

...</pre><pre class="codeoutput">
y1 =

  1&times;6 logical array

...</pre><pre class="codeoutput">
temp =

  Columns 1 through 13

...</pre><p><b>[y,n] = stepseq(n0,a,b)</b></p><pre class="codeinput"><span class="keyword">function</span> [x,n]=stepseq(n0,a,b)
<span class="comment">% Generates x(n)= u(n-n0); a&lt;=n&lt;=b</span>
n=[a:b]; x=[(n-n0)&gt;=0];
<span class="keyword">end</span>
</pre><pre class="codeoutput">
y =

  1&times;6 logical array

...</pre><pre class="codeoutput">
y2 =

  1&times;6 logical array

...</pre><p><b>[y,n] = sigadd(x1,n1,x2,n2)</b></p><pre class="codeinput"><span class="keyword">function</span> [y,n]=sigadd(x1,n1,x2,n2)
n=min(min(n1),min(n2)): max(max(n1),max(n2));
y1=zeros(1,length(n)); y2=y1;
y1(find((n&gt;=min(n1))&amp;(n&lt;=max(n1))==1))=x1;
y2(find((n&gt;=min(n2))&amp;(n&lt;=max(n2))==1))=x2;
y=y1+y2;
<span class="keyword">end</span>
</pre><pre class="codeoutput">
y =

     0     0     0     2     1     1

...</pre><p><b>[y,n] = sigmult(x1,n1,x2,n2)</b></p><pre class="codeinput"><span class="keyword">function</span> [y,n] = sigmult(x1,n1,x2,n2)
<span class="comment">% implements y(n) = x1(n)*x2(n)</span>
n = min(min(n1),min(n2)):max(max(n1),max(n2)); <span class="comment">% duration of y(n)</span>
y1 = zeros(1,length(n)); y2 = y1; <span class="comment">%</span>
y1(find((n&gt;=min(n1))&amp;(n&lt;=max(n1))==1))=x1; <span class="comment">% x1 with duration of y</span>
y2(find((n&gt;=min(n2))&amp;(n&lt;=max(n2))==1))=x2; <span class="comment">% x2 with duration of y</span>
y = y1 .* y2; <span class="comment">% sequence multiplication</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
y =

     0     0     0     1     0     0

...</pre><pre class="codeoutput">
y =

     0     0     0     1     0     0

...</pre><pre class="codeinput"><span class="keyword">function</span> [y,n] = sigshift(x,n1,n0)
<span class="comment">% implements y(n) = x(n-n0)</span>
n = n1+n0; y = x;
<span class="keyword">end</span>
</pre><pre class="codeoutput">
y =

  1&times;6 logical array

...</pre><pre class="codeinput"><span class="keyword">function</span> [y,n] = sigfold(x,n)
<span class="comment">% implements y(n) = x(-n)</span>
<span class="comment">% -----------------------</span>
<span class="comment">% [y,n] = sigfold(x,n)</span>
<span class="comment">%</span>
y = fliplr(x); n = -fliplr(n);
<span class="keyword">end</span>
</pre><pre class="codeoutput">
y =

  1&times;6 logical array

...</pre><p>odd even decomposition function</p><pre class="codeinput"><span class="keyword">function</span> [xe,xo,m] = evenodd(x,n)
<span class="keyword">if</span> any(imag(x)~=0)
    error(<span class="string">'x is not real sequence '</span>)
<span class="keyword">end</span>
m = -fliplr(n);
m1 = min([m,n]);
m2 = max([m,n]);
m = m1:m2;
nm = n(1)-m(1);
n1 = 1:length(n);
x1 = zeros(1,length(m));
x1(n1+nm) = x;
x = x1;
xe = 0.5*(x+fliplr(x));
xo = 0.5*(x-fliplr(x));
<span class="keyword">end</span>
</pre><pre class="codeoutput">
xe =

  Columns 1 through 7

...</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% EE 274 Digital Signal Processing 1 Lab Activity 1
% Name: Paul Vincent S. Nonat
%

%% A. Signal Generation
% In this exercise, you will demonstrate your coding skills in MATLAB by
% generating the following signals:
%
% 
% # [y,n] = impseq(n0,a,b) 
% # [y,n] = stepseq(n0,a,b)
% # [y,n] = sigadd(x1,n1,x2,n2)
% # [y,n] = sigmult(x1,n1,x2,n2)
% # [y,n] = sigshift(x1,n1,n0)
% # [y,n] = sigfold(x1,n1)
% # [xe,xo,n] = evenodd(x1,n1)

%% 
% * Demo of impseq function *[y,n] = impseq(n0,a,b)*
[y,n] = impseq(3,0,5)
figure
stem (n,y)
title('A.1. Unit-Impulse Sequence')
xlabel('n')
ylabel('x(n)')

%%
% * Demo of Unit-step sequence function *[y,n] = stepseq(n0,a,b)*
[y,n]  = stepseq(3,0,5)
figure
stem(n,y)
title('A.2. Unit-step Sequence')
xlabel('n')
ylabel('x(n)')

%%
% * Demo of addition of two sequence  *[y,n] = sigadd(x1,n1,x2,n2)*
[y1,n1] = impseq(3,0,5) %generate impulse sequence
[y2,n2]  = stepseq(3,0,5) %generate unit-step sequence
[y,n] = sigadd(y1,n1,y2,n2) % add the unit step and unit impulse sequence
figure
stem(n,y)
title('A.3 Addition of Two Sequence')
ylabel('y = x1(n1)+ x2(n2)')
xlabel('n')

%%
% * Demo of multiplication of two sequence *[y,n] = sigmult(x1,n1,x2,n2)*
[y1,n1] = impseq(3,0,5) %generate impulse sequence
[y2,n2]  = stepseq(3,0,5) %generate unit-step sequence
[y,n] = sigmult(y1,n1,y2,n2) % add the unit step and unit impulse sequence
figure
stem(n,y)
title('A.4 Multiplication of Two Sequence')
ylabel('y = x1(n1)* x2(n2)')
xlabel('n')


%%
% * Demo of signal shifting *[y,n] = sigshift(x1,n1,n0)*
[y1,n1] = impseq(3,0,5) % generate impulse sequence
[y,n] = sigshift(y1,n1,1) % shift impulse sequence by 1
figure
stem(n,y)
title('A.5 Shifting Operation on a Sequence')
ylabel('x[n-n0]')
xlabel('n')

%%
% # Demo of signal folding  *[y,n] = sigfold(x1,n1)*
[y1,n1]  = stepseq(3,0,5)
[y,n]= sigfold(y1,n1)
figure
stem(n,y)
title('A.6 Folding operation on a sequence')
ylabel('FD[x(n)]')
xlabel('n')

%%
% * Demo of odd even signal decomposition *[xe,xo,m] = evenodd(x,n)*
[y1,n1] = impseq(3,0,5) %generate impulse sequence
[y2,n2]  = stepseq(3,0,5) %generate unit-step sequence
[y,n] = sigmult(y1,n1,y2,n2) % add the unit step and unit impulse sequence
[xe,xo,m] = evenodd(y,n)
subplot(311)
stem(n,y)
title('Original')
subplot(312)
stem(m,xe)
title('Even Part')
subplot(313)
stem(m,xo)
title('Odd Part')

%% B. SIGNAL REPRESENTATION
% Generate and Plot the following signals. You may use your functions in
% Part A.
% 
% $$x_1(n) = \sum_{m=0}^{10}(m+1)[\delta(n-2m) - \delta(n-2m-1)]$
%
y=0
N=25
nn=0:N
for n =0:N
for m =0:10
    temp=(m+1) .*( impseq(n-2*m,0,N) - impseq(n-(2*m)-1,0,N))
    y=y+temp
end
end
figure
stem(nn,y)
xlabel('n')
title('$x_1(n) = \sum_{m=0}^{10}(m+1)[\delta(n-2m) - \delta(n-2m-1)]$','interpreter','latex')

%%
% $x_2(n) = n^2[ u(n+5) - u(n-6)] + 10\delta(n) +20(0.5)n[u(n-4)-u(n-10)]$
%
y=0
N=25
nn=0:N
for n=0:25
temp = n^2 .* (stepseq(n+5,0,N) - stepseq(n-6,0,N)) + (10 .* impseq(n,0,N)) + 20*(0.5)^n .*(stepseq(n-4,0,N) - stepseq(n-1,0,N)) 
y=y+temp
end
figure
stem(nn,y)
xlabel('n')
title('$x_2(n) = n^2[ u(n+5) - u(n-6)] + 10\delta(n) +20(0.5)n[u(n-4)-u(n-10)]$','interpreter','latex')
%%
% $x_3(n)= (0.9)^n cos(0.2\pi n + \frac{\pi}{3})$
%
N=20
n = 0:N;
x0 = 0.9;
x = (0.9^L)*cos(0.2*pi*n+(pi/3));
stem(n,x)
xlabel('n')
title(' $x_3(n)= (0.9)^n cos(0.2\pi n + \frac{\pi}{3})$','interpreter','latex')

%%
% $x_4(n) = 10cos(0.0008\pi n^2) + w(n)$
%
N=100
n=0:N;
x0=10;
w = -1+2*rand(1,N+1);
x =(x0*cos(0.0008*pi*(n.^2))) + w
stem(n,x)
xlabel('n')
title(' $x_4(n) = 10cos(0.0008\pi n^2) + w(n)$','interpreter','latex')

%%
% $x_5(n) = {...,1,2,3,2,1,2,3,2,...}$
%
%N=20
%
%y,n]  = stepseq(0,0,2)
%% C. Sampling
%Sampling is done by periodically obtaining samples from a continuous time
%signal. The period also known as the sampling period is the reciprocal of
%sampling frequency $F_s$. Using up-sampling and down-sampling, information
%can be added or removed from a discrete time signal.
%
% # Load *signal1.wave* file in your workspace
% # Using *[y,fs] = audioread()*, import the audio and sampling rate
% information in your workspace.
%
[y,fs]=audioread('signal1.wav');
info=audioinfo('signal1.wav');
t = 0:seconds(1/fs):seconds(info.Duration);
t = t(1:end-1);

plot(t,y)
title('Original Audio')
xlabel('Time')
ylabel('Audio Signal')
soundsc(y,fs)
%%
%y up-sampled by 2
M=2
y1= upsample(y,M)
t1 = 0:seconds(1/(M*fs)):seconds(info.Duration);
t1 = t1(1:end-1);
figure
plot(t1,y1)
title('y Up-sampled by 2')
xlabel('Time')
ylabel('y1=y(n/2)')
soundsc(y1,fs)

%%
%y down-sampled by 2
M=2
y2= downsample(y,M)
t2 = 0:seconds(1/(fs/M)):seconds(info.Duration);
t2 = t2(1:end-1);
figure
plot(t2,y2)
title('y down-sampled by 2')
xlabel('Time')
ylabel('y2=y(2n)')
soundsc(y2,fs)

%%
%y2 up-sampled by 2
M=2
y3 = upsample(y2,M)
t3 = 0:seconds(1/fs):seconds(info.Duration);
t3 = t3(1:end-1);
figure
plot(t3,y3)
title('y2 up-sampled by 2')
xlabel('Time')
ylabel('y3=y2(n/2)')
soundsc(y3,fs)

%%
%y3, up-sampled by 2
M=2
y4 = upsample(y3,M)
t4 = 0:seconds(1/(fs*M)):seconds(info.Duration);
t4 = t4(1:end-1);
figure
plot(t4,y4)
title('y3 up-sampled by 2')
xlabel('Time')
ylabel('y4=y3(n/2)')
soundsc(y4,fs)

%yes however some information will be loss as the upsampler cannot predict 
%the value inbetween the downsampled signales. In effect, there are loss 
%information in the upsampled signals $y_3$ and $y_4$.

%% D. Aliasing
% The following exercise investigates the effect of improper sampling.
% 
% # Generate two 1 kHz sine signals (2 seconds duration), first signal at 8 kHz sample frequency and second signal at 1.2 kHz sample frequency
% # On the same graph, use the plot function to display the two signals versus t in the range $0 \leq t \leq 5$ msec.
% # Listen to the two signals one after another using the function *soundsc (x, fs)*; 
% # Compare the two signals. How does the sampling rate affect the digitized sound?

%%
T = 2; %parameters
f0 = 1000; % 1kHz sine signal 
fs1 = 8000; % Sampling frequencies
fs2 = 1200;
[x1, t1] = sin_NU(fs1,f0,T); % sine signal sampled at fs1
[x2, t2] = sin_NU(fs2,f0,T); % sine signal sampled at fs2
figure;
plot(t1,x1,t2,x2,'LineWidth',3.0),
axis([0, 0.005, -1.1, 1.1])
legend('fs_1=8 kHz','fs_2=1.2 kHz')
xlabel('Time')
ylabel('Signals')
title('Audio aliasing');
%%
soundsc(x1,fs1)
%%
soundsc(x2,fs2)

%%
% based from observation, the sine wave sampled at $F_s2$ does not
% completely recovered the original sine wave at $f_o =1$kHz as compared to
% $F_s1$ with frequency lower than $2F_max$, which leads to aliasing. 


%% E. Quantization
%Quantization is done by replacing each value of an analog signal $x(t)$ by
%the value of the nearest quantization level. To exemplify this oepration,
%let's simulate a unipolar ADC (Analog to Digital Converter) having the
%technical specifications: R= 10 Volts (full-scale range) and B = 3(number
%of bits).
% 
% # Write a MATLAB function y=adc_uni(x,R,B) where x and y are vectors
% containing the input signal and the quantized signal, respectively.
% # Test your function with an input ramp signal ranging from -5 to 15
% Volts (1 volt per step).
% # On the same graph, use the plot and stem functions to display the input
% signal and quantized signal respectively.

%%
% adc_uni function test
R = 10;
B = 3;
x = -5:15;
y = adc_uni(x,R,B);
t = 0:length(x)-1;
figure(11)
plot(t,x,t,y)
plot(t,x,'g-*','LineWidth',2.2)
hold on
stem(t,y,'filled','LineWidth',2.2)
hold off
title('Ramp function unipolar quantization')
xlabel('Time in sec')
ylabel('Signal magnitude in volts')
axis([-0.1,20.1,-5.1,15.1]) 

%%
function y = adc_uni(x, R, B)
level = [0:R/(2^B):R-R/(2^B)];
temp = [-Inf,(level(2:end)-R/(2^(B+1))),Inf];
i=1
y=(x >= temp(i)).*(x < temp(i+1)).*level(i)
for i = 2:length(level)
    y = y + (x >= temp(i)).*(x < temp(i+1)).*level(i);
end
end

%%
function [x, t] = sin_NU(fs, f0, T) %function to generate sine signal
t = 0:1/fs:T; %the signal vector output
x = sin(2*pi*f0*t); %the time vector output
end

%% 
%
function [x,n]=impseq(n0,a,b)
% Generates x(n)= delta(n-n0); a<=n<=b
n=[a:b]; x=[(n-n0)==0]; 
end

%% 
% *[y,n] = stepseq(n0,a,b)*
function [x,n]=stepseq(n0,a,b)
% Generates x(n)= u(n-n0); a<=n<=b
n=[a:b]; x=[(n-n0)>=0]; 
end

%%
% *[y,n] = sigadd(x1,n1,x2,n2)*
function [y,n]=sigadd(x1,n1,x2,n2)
n=min(min(n1),min(n2)): max(max(n1),max(n2));
y1=zeros(1,length(n)); y2=y1;
y1(find((n>=min(n1))&(n<=max(n1))==1))=x1;
y2(find((n>=min(n2))&(n<=max(n2))==1))=x2;
y=y1+y2; 
end

%%
% *[y,n] = sigmult(x1,n1,x2,n2)*
function [y,n] = sigmult(x1,n1,x2,n2)
% implements y(n) = x1(n)*x2(n)
n = min(min(n1),min(n2)):max(max(n1),max(n2)); % duration of y(n)
y1 = zeros(1,length(n)); y2 = y1; %
y1(find((n>=min(n1))&(n<=max(n1))==1))=x1; % x1 with duration of y
y2(find((n>=min(n2))&(n<=max(n2))==1))=x2; % x2 with duration of y
y = y1 .* y2; % sequence multiplication
end

%%
%
function [y,n] = sigshift(x,n1,n0)
% implements y(n) = x(n-n0)
n = n1+n0; y = x;
end
%%
%
function [y,n] = sigfold(x,n)
% implements y(n) = x(-n)
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% [y,n] = sigfold(x,n)
%
y = fliplr(x); n = -fliplr(n);
end

%%
% odd even decomposition function
function [xe,xo,m] = evenodd(x,n)
if any(imag(x)~=0)
    error('x is not real sequence ')
end
m = -fliplr(n);
m1 = min([m,n]);
m2 = max([m,n]);
m = m1:m2;
nm = n(1)-m(1);
n1 = 1:length(n);
x1 = zeros(1,length(m));
x1(n1+nm) = x;
x = x1;
xe = 0.5*(x+fliplr(x));
xo = 0.5*(x-fliplr(x));
end
##### SOURCE END #####
--></body></html>